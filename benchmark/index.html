<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snap DnD Benchmark</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
    h1 { margin-bottom: 20px; }
    .controls { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
    button { padding: 10px 20px; font-size: 14px; cursor: pointer; background: #4a4a6a; color: #fff; border: none; border-radius: 4px; transition: all 0.15s; }
    button:hover { background: #5a5a7a; transform: translateY(-1px); }
    .results { background: #2a2a4a; padding: 20px; border-radius: 8px; margin-bottom: 20px; font-family: monospace; white-space: pre-wrap; max-height: 200px; overflow-y: auto; }
    .container { display: flex; gap: 20px; flex-wrap: wrap; }
    .column {
      background: #2a2a4a;
      padding: 10px;
      border-radius: 8px;
      min-width: 200px;
      min-height: 400px;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .column.snap-drop-active {
      background: #3a3a5a;
      box-shadow: inset 0 0 0 2px #6c63ff;
    }
    .item {
      background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
      padding: 12px 15px;
      margin: 8px 0;
      border-radius: 6px;
      cursor: grab;
      user-select: none;
      touch-action: none;
      transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1),
                  box-shadow 0.2s,
                  opacity 0.2s;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .item:hover:not(.snap-dragging) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .item:active { cursor: grabbing; }

    /* Disable transitions during drag for snappy feel */
    body.is-dragging .item {
      transition: none !important;
    }

    /* Dragging state - hide original since placeholder takes its place */
    .snap-dragging {
      opacity: 0 !important;
      pointer-events: none !important;
      position: absolute !important;
      visibility: hidden !important;
    }

    /* Ghost element - the "picked up" card */
    .snap-ghost {
      /* Don't override transform - library uses it for positioning! */
      box-shadow:
        0 25px 50px rgba(0,0,0,0.4),
        0 10px 20px rgba(0,0,0,0.3),
        0 0 0 1px rgba(108, 99, 255, 0.3) !important;
      background: linear-gradient(135deg, #5a5a7a 0%, #4a4a6a 100%) !important;
      cursor: grabbing !important;
      z-index: 10000 !important;
      filter: brightness(1.1);
    }

    /* Placeholder - subtle gap indicator */
    .snap-sortable-placeholder {
      background: rgba(108, 99, 255, 0.08) !important;
      border: 2px dashed rgba(108, 99, 255, 0.25) !important;
      border-radius: 6px;
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <h1>Snap DnD Benchmark</h1>

  <div class="controls">
    <button onclick="runMemoryTest()">Memory Test (100,000 items)</button>
    <button onclick="runInitTest()">Init Speed Test</button>
    <button onclick="runDragSimulation()">Drag Simulation (100 ops)</button>
    <button onclick="clearResults()">Clear</button>
  </div>

  <div class="results" id="results">Click a test to run benchmarks...</div>

  <div class="container" id="container">
    <div class="column" data-droppable>
      <div class="item" data-draggable>Item 1</div>
      <div class="item" data-draggable>Item 2</div>
      <div class="item" data-draggable>Item 3</div>
    </div>
    <div class="column" data-droppable>
      <div class="item" data-draggable>Item 4</div>
      <div class="item" data-draggable>Item 5</div>
    </div>
  </div>

  <script type="module">
    import { Snap, Sortable } from '../dist/snap.esm.js';

    const results = document.getElementById('results');
    const container = document.getElementById('container');

    let snap = new Snap(container, {
      distance: 3,
      throttle: false, // Disable RAF throttling for snappy feel
      onDragStart: (e) => {
        document.body.classList.add('is-dragging');
        e.element.style.transition = 'none';
      },
      onDropZoneEnter: (e) => {
        e.dropZone.classList.add('snap-drop-active');
      },
      onDropZoneLeave: (e) => {
        e.dropZone.classList.remove('snap-drop-active');
      },
      onDrop: (e) => {
        const { element, dropZone, insertionIndex } = e;

        document.querySelectorAll('.snap-drop-active').forEach(el =>
          el.classList.remove('snap-drop-active')
        );

        if (dropZone && insertionIndex !== undefined) {
          const items = dropZone.querySelectorAll('.item');
          // Animate the drop
          element.style.transition = 'transform 0.15s ease';
          element.style.transform = 'scale(0.98)';

          setTimeout(() => {
            if (insertionIndex >= items.length) {
              dropZone.appendChild(element);
            } else {
              dropZone.insertBefore(element, items[insertionIndex]);
            }
            element.style.transform = '';
            setTimeout(() => {
              element.style.transition = '';
            }, 150);
          }, 10);
        }
      },
      onDragEnd: (e) => {
        document.body.classList.remove('is-dragging');
        document.querySelectorAll('.snap-drop-active').forEach(el =>
          el.classList.remove('snap-drop-active')
        );
      }
    }).use(new Sortable({ animation: 150 }));

    function log(msg) {
      results.textContent += msg + '\n';
      console.log(msg);
    }

    function clearResults() {
      results.textContent = '';
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    // Memory test - create many items
    window.runMemoryTest = async function() {
      log('\n=== Memory Test ===');

      // Force GC if available
      if (window.gc) window.gc();

      const before = performance.memory?.usedJSHeapSize || 0;

      // Destroy existing
      snap.destroy();
      container.innerHTML = '';

      // Create 100,000 items
      const col = document.createElement('div');
      col.className = 'column';
      col.setAttribute('data-droppable', '');

      const start = performance.now();
      const fragment = document.createDocumentFragment();

      for (let i = 0; i < 100000; i++) {
        const item = document.createElement('div');
        item.className = 'item';
        item.setAttribute('data-draggable', '');
        item.textContent = `Item ${i + 1}`;
        fragment.appendChild(item);
      }
      col.appendChild(fragment);

      container.appendChild(col);

      // Reinitialize Snap with same config
      snap = new Snap(container, {
        onDropZoneEnter: (e) => e.dropZone.classList.add('snap-drop-active'),
        onDropZoneLeave: (e) => e.dropZone.classList.remove('snap-drop-active'),
        onDrop: (e) => {
          const { element, dropZone, insertionIndex } = e;
          document.querySelectorAll('.snap-drop-active').forEach(el =>
            el.classList.remove('snap-drop-active')
          );
          if (dropZone && insertionIndex !== undefined) {
            const items = dropZone.querySelectorAll('.item');
            if (insertionIndex >= items.length) {
              dropZone.appendChild(element);
            } else {
              dropZone.insertBefore(element, items[insertionIndex]);
            }
          }
        }
      }).use(new Sortable({ animation: 200 }));

      const initTime = performance.now() - start;

      // Check memory after
      await new Promise(r => setTimeout(r, 100));
      const after = performance.memory?.usedJSHeapSize || 0;

      log(`Items created: 100,000`);
      log(`Init time: ${initTime.toFixed(2)}ms`);

      if (before && after) {
        log(`Memory before: ${formatBytes(before)}`);
        log(`Memory after: ${formatBytes(after)}`);
        log(`Memory delta: ${formatBytes(after - before)}`);
        log(`Per-item overhead: ~${((after - before) / 100000).toFixed(0)} bytes`);
      } else {
        log('(Memory API not available - run Chrome with --enable-precise-memory-info)');
      }
    };

    // Init speed test
    window.runInitTest = function() {
      log('\n=== Init Speed Test (100 iterations) ===');

      const times = [];

      for (let i = 0; i < 100; i++) {
        snap.destroy();

        const start = performance.now();
        snap = new Snap(container, {
          onDrop: () => {}
        }).use(new Sortable());
        times.push(performance.now() - start);
      }

      const avg = times.reduce((a, b) => a + b, 0) / times.length;
      const min = Math.min(...times);
      const max = Math.max(...times);

      log(`Average init: ${avg.toFixed(3)}ms`);
      log(`Min: ${min.toFixed(3)}ms`);
      log(`Max: ${max.toFixed(3)}ms`);
      log(`Ops/sec: ${(1000 / avg).toFixed(0)}`);
    };

    // Simulate drag operations
    window.runDragSimulation = function() {
      log('\n=== Drag Event Simulation (100 ops) ===');

      const items = container.querySelectorAll('.item');
      if (items.length === 0) {
        log('No items to test. Run memory test first.');
        return;
      }

      const start = performance.now();

      // Simulate 100 pointer events
      for (let i = 0; i < 100; i++) {
        const item = items[i % items.length];
        const rect = item.getBoundingClientRect();

        // Simulate pointerdown
        item.dispatchEvent(new PointerEvent('pointerdown', {
          bubbles: true,
          clientX: rect.left + 10,
          clientY: rect.top + 10,
          pointerId: 1,
          isPrimary: true,
          button: 0
        }));

        // Simulate pointermove
        for (let j = 0; j < 5; j++) {
          document.dispatchEvent(new PointerEvent('pointermove', {
            bubbles: true,
            clientX: rect.left + 10 + j * 10,
            clientY: rect.top + 10 + j * 10,
            pointerId: 1,
            isPrimary: true
          }));
        }

        // Simulate pointerup
        document.dispatchEvent(new PointerEvent('pointerup', {
          bubbles: true,
          clientX: rect.left + 60,
          clientY: rect.top + 60,
          pointerId: 1,
          isPrimary: true
        }));
      }

      const elapsed = performance.now() - start;

      log(`100 drag operations: ${elapsed.toFixed(2)}ms`);
      log(`Per operation: ${(elapsed / 100).toFixed(3)}ms`);
      log(`Ops/sec: ${(100000 / elapsed).toFixed(0)}`);
    };

    window.clearResults = clearResults;
  </script>
</body>
</html>
